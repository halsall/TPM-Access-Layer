// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Request;
class Reply;
class Reply_RegisterInfoType;

enum Request_CommandType {
  Request_CommandType_CONNECT = 1,
  Request_CommandType_DISCONNECT = 2,
  Request_CommandType_RESET_BOARD = 3,
  Request_CommandType_GET_STATUS = 4,
  Request_CommandType_GET_REGISTER_LIST = 5,
  Request_CommandType_GET_REGISTER_VALUE = 6,
  Request_CommandType_SET_REGISTER_VALUE = 7,
  Request_CommandType_GET_REGISTER_VALUES = 8,
  Request_CommandType_SET_REGISTER_VALUES = 9,
  Request_CommandType_LOAD_FIRMWARE = 10,
  Request_CommandType_LOAD_FIRMWARE_BLOCKING = 11
};
bool Request_CommandType_IsValid(int value);
const Request_CommandType Request_CommandType_CommandType_MIN = Request_CommandType_CONNECT;
const Request_CommandType Request_CommandType_CommandType_MAX = Request_CommandType_LOAD_FIRMWARE_BLOCKING;
const int Request_CommandType_CommandType_ARRAYSIZE = Request_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_CommandType_descriptor();
inline const ::std::string& Request_CommandType_Name(Request_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_CommandType_descriptor(), value);
}
inline bool Request_CommandType_Parse(
    const ::std::string& name, Request_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_CommandType>(
    Request_CommandType_descriptor(), name, value);
}
enum Request_DeviceType {
  Request_DeviceType_BOARD = 1,
  Request_DeviceType_FPGA_1 = 2,
  Request_DeviceType_FPGA_2 = 3
};
bool Request_DeviceType_IsValid(int value);
const Request_DeviceType Request_DeviceType_DeviceType_MIN = Request_DeviceType_BOARD;
const Request_DeviceType Request_DeviceType_DeviceType_MAX = Request_DeviceType_FPGA_2;
const int Request_DeviceType_DeviceType_ARRAYSIZE = Request_DeviceType_DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_DeviceType_descriptor();
inline const ::std::string& Request_DeviceType_Name(Request_DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_DeviceType_descriptor(), value);
}
inline bool Request_DeviceType_Parse(
    const ::std::string& name, Request_DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_DeviceType>(
    Request_DeviceType_descriptor(), name, value);
}
enum Request_RegisterType {
  Request_RegisterType_SENSOR = 1,
  Request_RegisterType_BOARD_REGISTER = 2,
  Request_RegisterType_FIRMWARE_REGISTER = 3
};
bool Request_RegisterType_IsValid(int value);
const Request_RegisterType Request_RegisterType_RegisterType_MIN = Request_RegisterType_SENSOR;
const Request_RegisterType Request_RegisterType_RegisterType_MAX = Request_RegisterType_FIRMWARE_REGISTER;
const int Request_RegisterType_RegisterType_ARRAYSIZE = Request_RegisterType_RegisterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RegisterType_descriptor();
inline const ::std::string& Request_RegisterType_Name(Request_RegisterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RegisterType_descriptor(), value);
}
inline bool Request_RegisterType_Parse(
    const ::std::string& name, Request_RegisterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RegisterType>(
    Request_RegisterType_descriptor(), name, value);
}
enum Reply_ResultType {
  Reply_ResultType_SUCCESS = 0,
  Reply_ResultType_FAILURE = -1,
  Reply_ResultType_NOT_IMPLEMENTED = -2
};
bool Reply_ResultType_IsValid(int value);
const Reply_ResultType Reply_ResultType_ResultType_MIN = Reply_ResultType_NOT_IMPLEMENTED;
const Reply_ResultType Reply_ResultType_ResultType_MAX = Reply_ResultType_SUCCESS;
const int Reply_ResultType_ResultType_ARRAYSIZE = Reply_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_ResultType_descriptor();
inline const ::std::string& Reply_ResultType_Name(Reply_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_ResultType_descriptor(), value);
}
inline bool Reply_ResultType_Parse(
    const ::std::string& name, Reply_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_ResultType>(
    Reply_ResultType_descriptor(), name, value);
}
enum Reply_TpmStatus {
  Reply_TpmStatus_OK = 0,
  Reply_TpmStatus_LOADING_FIRMWARE = -1,
  Reply_TpmStatus_CONFIG_ERROR = -2,
  Reply_TpmStatus_BOARD_ERROR = -3,
  Reply_TpmStatus_NOT_CONNECTED = -4,
  Reply_TpmStatus_NETWORK_ERROR = -5
};
bool Reply_TpmStatus_IsValid(int value);
const Reply_TpmStatus Reply_TpmStatus_TpmStatus_MIN = Reply_TpmStatus_NETWORK_ERROR;
const Reply_TpmStatus Reply_TpmStatus_TpmStatus_MAX = Reply_TpmStatus_OK;
const int Reply_TpmStatus_TpmStatus_ARRAYSIZE = Reply_TpmStatus_TpmStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_TpmStatus_descriptor();
inline const ::std::string& Reply_TpmStatus_Name(Reply_TpmStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_TpmStatus_descriptor(), value);
}
inline bool Reply_TpmStatus_Parse(
    const ::std::string& name, Reply_TpmStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_TpmStatus>(
    Reply_TpmStatus_descriptor(), name, value);
}
enum Reply_PermissionType {
  Reply_PermissionType_READ = 1,
  Reply_PermissionType_WRITE = 2,
  Reply_PermissionType_READWRITE = 3
};
bool Reply_PermissionType_IsValid(int value);
const Reply_PermissionType Reply_PermissionType_PermissionType_MIN = Reply_PermissionType_READ;
const Reply_PermissionType Reply_PermissionType_PermissionType_MAX = Reply_PermissionType_READWRITE;
const int Reply_PermissionType_PermissionType_ARRAYSIZE = Reply_PermissionType_PermissionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_PermissionType_descriptor();
inline const ::std::string& Reply_PermissionType_Name(Reply_PermissionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_PermissionType_descriptor(), value);
}
inline bool Reply_PermissionType_Parse(
    const ::std::string& name, Reply_PermissionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_PermissionType>(
    Reply_PermissionType_descriptor(), name, value);
}
enum Reply_DeviceType {
  Reply_DeviceType_BOARD = 1,
  Reply_DeviceType_FPGA_1 = 2,
  Reply_DeviceType_FPGA_2 = 3
};
bool Reply_DeviceType_IsValid(int value);
const Reply_DeviceType Reply_DeviceType_DeviceType_MIN = Reply_DeviceType_BOARD;
const Reply_DeviceType Reply_DeviceType_DeviceType_MAX = Reply_DeviceType_FPGA_2;
const int Reply_DeviceType_DeviceType_ARRAYSIZE = Reply_DeviceType_DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_DeviceType_descriptor();
inline const ::std::string& Reply_DeviceType_Name(Reply_DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_DeviceType_descriptor(), value);
}
inline bool Reply_DeviceType_Parse(
    const ::std::string& name, Reply_DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_DeviceType>(
    Reply_DeviceType_descriptor(), name, value);
}
enum Reply_RegisterType {
  Reply_RegisterType_SENSOR = 1,
  Reply_RegisterType_BOARD_REGISTER = 2,
  Reply_RegisterType_FIRMWARE_REGISTER = 3
};
bool Reply_RegisterType_IsValid(int value);
const Reply_RegisterType Reply_RegisterType_RegisterType_MIN = Reply_RegisterType_SENSOR;
const Reply_RegisterType Reply_RegisterType_RegisterType_MAX = Reply_RegisterType_FIRMWARE_REGISTER;
const int Reply_RegisterType_RegisterType_ARRAYSIZE = Reply_RegisterType_RegisterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reply_RegisterType_descriptor();
inline const ::std::string& Reply_RegisterType_Name(Reply_RegisterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reply_RegisterType_descriptor(), value);
}
inline bool Reply_RegisterType_Parse(
    const ::std::string& name, Reply_RegisterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reply_RegisterType>(
    Reply_RegisterType_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_CommandType CommandType;
  static const CommandType CONNECT = Request_CommandType_CONNECT;
  static const CommandType DISCONNECT = Request_CommandType_DISCONNECT;
  static const CommandType RESET_BOARD = Request_CommandType_RESET_BOARD;
  static const CommandType GET_STATUS = Request_CommandType_GET_STATUS;
  static const CommandType GET_REGISTER_LIST = Request_CommandType_GET_REGISTER_LIST;
  static const CommandType GET_REGISTER_VALUE = Request_CommandType_GET_REGISTER_VALUE;
  static const CommandType SET_REGISTER_VALUE = Request_CommandType_SET_REGISTER_VALUE;
  static const CommandType GET_REGISTER_VALUES = Request_CommandType_GET_REGISTER_VALUES;
  static const CommandType SET_REGISTER_VALUES = Request_CommandType_SET_REGISTER_VALUES;
  static const CommandType LOAD_FIRMWARE = Request_CommandType_LOAD_FIRMWARE;
  static const CommandType LOAD_FIRMWARE_BLOCKING = Request_CommandType_LOAD_FIRMWARE_BLOCKING;
  static inline bool CommandType_IsValid(int value) {
    return Request_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Request_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Request_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Request_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Request_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Request_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Request_CommandType_Parse(name, value);
  }

  typedef Request_DeviceType DeviceType;
  static const DeviceType BOARD = Request_DeviceType_BOARD;
  static const DeviceType FPGA_1 = Request_DeviceType_FPGA_1;
  static const DeviceType FPGA_2 = Request_DeviceType_FPGA_2;
  static inline bool DeviceType_IsValid(int value) {
    return Request_DeviceType_IsValid(value);
  }
  static const DeviceType DeviceType_MIN =
    Request_DeviceType_DeviceType_MIN;
  static const DeviceType DeviceType_MAX =
    Request_DeviceType_DeviceType_MAX;
  static const int DeviceType_ARRAYSIZE =
    Request_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeviceType_descriptor() {
    return Request_DeviceType_descriptor();
  }
  static inline const ::std::string& DeviceType_Name(DeviceType value) {
    return Request_DeviceType_Name(value);
  }
  static inline bool DeviceType_Parse(const ::std::string& name,
      DeviceType* value) {
    return Request_DeviceType_Parse(name, value);
  }

  typedef Request_RegisterType RegisterType;
  static const RegisterType SENSOR = Request_RegisterType_SENSOR;
  static const RegisterType BOARD_REGISTER = Request_RegisterType_BOARD_REGISTER;
  static const RegisterType FIRMWARE_REGISTER = Request_RegisterType_FIRMWARE_REGISTER;
  static inline bool RegisterType_IsValid(int value) {
    return Request_RegisterType_IsValid(value);
  }
  static const RegisterType RegisterType_MIN =
    Request_RegisterType_RegisterType_MIN;
  static const RegisterType RegisterType_MAX =
    Request_RegisterType_RegisterType_MAX;
  static const int RegisterType_ARRAYSIZE =
    Request_RegisterType_RegisterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegisterType_descriptor() {
    return Request_RegisterType_descriptor();
  }
  static inline const ::std::string& RegisterType_Name(RegisterType value) {
    return Request_RegisterType_Name(value);
  }
  static inline bool RegisterType_Parse(const ::std::string& name,
      RegisterType* value) {
    return Request_RegisterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Request.CommandType command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline ::Request_CommandType command() const;
  inline void set_command(::Request_CommandType value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string registerName = 6;
  inline bool has_registername() const;
  inline void clear_registername();
  static const int kRegisterNameFieldNumber = 6;
  inline const ::std::string& registername() const;
  inline void set_registername(const ::std::string& value);
  inline void set_registername(const char* value);
  inline void set_registername(const char* value, size_t size);
  inline ::std::string* mutable_registername();
  inline ::std::string* release_registername();
  inline void set_allocated_registername(::std::string* registername);

  // optional .Request.RegisterType registerFamily = 7;
  inline bool has_registerfamily() const;
  inline void clear_registerfamily();
  static const int kRegisterFamilyFieldNumber = 7;
  inline ::Request_RegisterType registerfamily() const;
  inline void set_registerfamily(::Request_RegisterType value);

  // optional .Request.DeviceType device = 8;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 8;
  inline ::Request_DeviceType device() const;
  inline void set_device(::Request_DeviceType value);

  // optional uint32 n = 9;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 9;
  inline ::google::protobuf::uint32 n() const;
  inline void set_n(::google::protobuf::uint32 value);

  // optional string file = 10;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 10;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional uint32 value = 11;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 11;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // repeated uint32 values = 12;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 12;
  inline ::google::protobuf::uint32 values(int index) const;
  inline void set_values(int index, ::google::protobuf::uint32 value);
  inline void add_values(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_registername();
  inline void clear_has_registername();
  inline void set_has_registerfamily();
  inline void clear_has_registerfamily();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  int command_;
  ::google::protobuf::int32 port_;
  ::std::string* registername_;
  ::google::protobuf::int32 id_;
  int registerfamily_;
  int device_;
  ::google::protobuf::uint32 n_;
  ::std::string* file_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Reply_RegisterInfoType : public ::google::protobuf::Message {
 public:
  Reply_RegisterInfoType();
  virtual ~Reply_RegisterInfoType();

  Reply_RegisterInfoType(const Reply_RegisterInfoType& from);

  inline Reply_RegisterInfoType& operator=(const Reply_RegisterInfoType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply_RegisterInfoType& default_instance();

  void Swap(Reply_RegisterInfoType* other);

  // implements Message ----------------------------------------------

  Reply_RegisterInfoType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply_RegisterInfoType& from);
  void MergeFrom(const Reply_RegisterInfoType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .Reply.RegisterType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Reply_RegisterType type() const;
  inline void set_type(::Reply_RegisterType value);

  // required .Reply.DeviceType device = 3;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline ::Reply_DeviceType device() const;
  inline void set_device(::Reply_DeviceType value);

  // required .Reply.PermissionType permission = 4;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 4;
  inline ::Reply_PermissionType permission() const;
  inline void set_permission(::Reply_PermissionType value);

  // required uint32 size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // required string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:Reply.RegisterInfoType)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int type_;
  int device_;
  int permission_;
  ::google::protobuf::uint32 size_;
  ::std::string* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Reply_RegisterInfoType* default_instance_;
};
// -------------------------------------------------------------------

class Reply : public ::google::protobuf::Message {
 public:
  Reply();
  virtual ~Reply();

  Reply(const Reply& from);

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reply& default_instance();

  void Swap(Reply* other);

  // implements Message ----------------------------------------------

  Reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Reply_RegisterInfoType RegisterInfoType;

  typedef Reply_ResultType ResultType;
  static const ResultType SUCCESS = Reply_ResultType_SUCCESS;
  static const ResultType FAILURE = Reply_ResultType_FAILURE;
  static const ResultType NOT_IMPLEMENTED = Reply_ResultType_NOT_IMPLEMENTED;
  static inline bool ResultType_IsValid(int value) {
    return Reply_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    Reply_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    Reply_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    Reply_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return Reply_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return Reply_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return Reply_ResultType_Parse(name, value);
  }

  typedef Reply_TpmStatus TpmStatus;
  static const TpmStatus OK = Reply_TpmStatus_OK;
  static const TpmStatus LOADING_FIRMWARE = Reply_TpmStatus_LOADING_FIRMWARE;
  static const TpmStatus CONFIG_ERROR = Reply_TpmStatus_CONFIG_ERROR;
  static const TpmStatus BOARD_ERROR = Reply_TpmStatus_BOARD_ERROR;
  static const TpmStatus NOT_CONNECTED = Reply_TpmStatus_NOT_CONNECTED;
  static const TpmStatus NETWORK_ERROR = Reply_TpmStatus_NETWORK_ERROR;
  static inline bool TpmStatus_IsValid(int value) {
    return Reply_TpmStatus_IsValid(value);
  }
  static const TpmStatus TpmStatus_MIN =
    Reply_TpmStatus_TpmStatus_MIN;
  static const TpmStatus TpmStatus_MAX =
    Reply_TpmStatus_TpmStatus_MAX;
  static const int TpmStatus_ARRAYSIZE =
    Reply_TpmStatus_TpmStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TpmStatus_descriptor() {
    return Reply_TpmStatus_descriptor();
  }
  static inline const ::std::string& TpmStatus_Name(TpmStatus value) {
    return Reply_TpmStatus_Name(value);
  }
  static inline bool TpmStatus_Parse(const ::std::string& name,
      TpmStatus* value) {
    return Reply_TpmStatus_Parse(name, value);
  }

  typedef Reply_PermissionType PermissionType;
  static const PermissionType READ = Reply_PermissionType_READ;
  static const PermissionType WRITE = Reply_PermissionType_WRITE;
  static const PermissionType READWRITE = Reply_PermissionType_READWRITE;
  static inline bool PermissionType_IsValid(int value) {
    return Reply_PermissionType_IsValid(value);
  }
  static const PermissionType PermissionType_MIN =
    Reply_PermissionType_PermissionType_MIN;
  static const PermissionType PermissionType_MAX =
    Reply_PermissionType_PermissionType_MAX;
  static const int PermissionType_ARRAYSIZE =
    Reply_PermissionType_PermissionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PermissionType_descriptor() {
    return Reply_PermissionType_descriptor();
  }
  static inline const ::std::string& PermissionType_Name(PermissionType value) {
    return Reply_PermissionType_Name(value);
  }
  static inline bool PermissionType_Parse(const ::std::string& name,
      PermissionType* value) {
    return Reply_PermissionType_Parse(name, value);
  }

  typedef Reply_DeviceType DeviceType;
  static const DeviceType BOARD = Reply_DeviceType_BOARD;
  static const DeviceType FPGA_1 = Reply_DeviceType_FPGA_1;
  static const DeviceType FPGA_2 = Reply_DeviceType_FPGA_2;
  static inline bool DeviceType_IsValid(int value) {
    return Reply_DeviceType_IsValid(value);
  }
  static const DeviceType DeviceType_MIN =
    Reply_DeviceType_DeviceType_MIN;
  static const DeviceType DeviceType_MAX =
    Reply_DeviceType_DeviceType_MAX;
  static const int DeviceType_ARRAYSIZE =
    Reply_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeviceType_descriptor() {
    return Reply_DeviceType_descriptor();
  }
  static inline const ::std::string& DeviceType_Name(DeviceType value) {
    return Reply_DeviceType_Name(value);
  }
  static inline bool DeviceType_Parse(const ::std::string& name,
      DeviceType* value) {
    return Reply_DeviceType_Parse(name, value);
  }

  typedef Reply_RegisterType RegisterType;
  static const RegisterType SENSOR = Reply_RegisterType_SENSOR;
  static const RegisterType BOARD_REGISTER = Reply_RegisterType_BOARD_REGISTER;
  static const RegisterType FIRMWARE_REGISTER = Reply_RegisterType_FIRMWARE_REGISTER;
  static inline bool RegisterType_IsValid(int value) {
    return Reply_RegisterType_IsValid(value);
  }
  static const RegisterType RegisterType_MIN =
    Reply_RegisterType_RegisterType_MIN;
  static const RegisterType RegisterType_MAX =
    Reply_RegisterType_RegisterType_MAX;
  static const int RegisterType_ARRAYSIZE =
    Reply_RegisterType_RegisterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegisterType_descriptor() {
    return Reply_RegisterType_descriptor();
  }
  static inline const ::std::string& RegisterType_Name(RegisterType value) {
    return Reply_RegisterType_Name(value);
  }
  static inline bool RegisterType_Parse(const ::std::string& name,
      RegisterType* value) {
    return Reply_RegisterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Reply.ResultType result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::Reply_ResultType result() const;
  inline void set_result(::Reply_ResultType value);

  // optional .Reply.PermissionType permission = 2;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 2;
  inline ::Reply_PermissionType permission() const;
  inline void set_permission(::Reply_PermissionType value);

  // optional .Reply.TpmStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::Reply_TpmStatus status() const;
  inline void set_status(::Reply_TpmStatus value);

  // optional uint32 value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // repeated uint32 values = 5;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 5;
  inline ::google::protobuf::uint32 values(int index) const;
  inline void set_values(int index, ::google::protobuf::uint32 value);
  inline void add_values(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  // repeated .Reply.RegisterInfoType registerList = 6;
  inline int registerlist_size() const;
  inline void clear_registerlist();
  static const int kRegisterListFieldNumber = 6;
  inline const ::Reply_RegisterInfoType& registerlist(int index) const;
  inline ::Reply_RegisterInfoType* mutable_registerlist(int index);
  inline ::Reply_RegisterInfoType* add_registerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Reply_RegisterInfoType >&
      registerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Reply_RegisterInfoType >*
      mutable_registerlist();

  // optional string message = 7;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 7;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int32 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Reply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int result_;
  int permission_;
  int status_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  ::google::protobuf::RepeatedPtrField< ::Reply_RegisterInfoType > registerlist_;
  ::std::string* message_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Reply* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// required .Request.CommandType command = 1;
inline bool Request::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_command() {
  command_ = 1;
  clear_has_command();
}
inline ::Request_CommandType Request::command() const {
  return static_cast< ::Request_CommandType >(command_);
}
inline void Request::set_command(::Request_CommandType value) {
  assert(::Request_CommandType_IsValid(value));
  set_has_command();
  command_ = value;
}

// optional string ip = 2;
inline bool Request::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Request::ip() const {
  return *ip_;
}
inline void Request::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Request::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Request::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Request::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool Request::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Request::port() const {
  return port_;
}
inline void Request::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 id = 4;
inline bool Request::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Request::id() const {
  return id_;
}
inline void Request::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string registerName = 6;
inline bool Request::has_registername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_registername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_registername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_registername() {
  if (registername_ != &::google::protobuf::internal::kEmptyString) {
    registername_->clear();
  }
  clear_has_registername();
}
inline const ::std::string& Request::registername() const {
  return *registername_;
}
inline void Request::set_registername(const ::std::string& value) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(value);
}
inline void Request::set_registername(const char* value) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(value);
}
inline void Request::set_registername(const char* value, size_t size) {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  registername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_registername() {
  set_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    registername_ = new ::std::string;
  }
  return registername_;
}
inline ::std::string* Request::release_registername() {
  clear_has_registername();
  if (registername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = registername_;
    registername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_registername(::std::string* registername) {
  if (registername_ != &::google::protobuf::internal::kEmptyString) {
    delete registername_;
  }
  if (registername) {
    set_has_registername();
    registername_ = registername;
  } else {
    clear_has_registername();
    registername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Request.RegisterType registerFamily = 7;
inline bool Request::has_registerfamily() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_registerfamily() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_registerfamily() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_registerfamily() {
  registerfamily_ = 1;
  clear_has_registerfamily();
}
inline ::Request_RegisterType Request::registerfamily() const {
  return static_cast< ::Request_RegisterType >(registerfamily_);
}
inline void Request::set_registerfamily(::Request_RegisterType value) {
  assert(::Request_RegisterType_IsValid(value));
  set_has_registerfamily();
  registerfamily_ = value;
}

// optional .Request.DeviceType device = 8;
inline bool Request::has_device() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_device() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_device() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_device() {
  device_ = 1;
  clear_has_device();
}
inline ::Request_DeviceType Request::device() const {
  return static_cast< ::Request_DeviceType >(device_);
}
inline void Request::set_device(::Request_DeviceType value) {
  assert(::Request_DeviceType_IsValid(value));
  set_has_device();
  device_ = value;
}

// optional uint32 n = 9;
inline bool Request::has_n() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_n() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_n() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_n() {
  n_ = 0u;
  clear_has_n();
}
inline ::google::protobuf::uint32 Request::n() const {
  return n_;
}
inline void Request::set_n(::google::protobuf::uint32 value) {
  set_has_n();
  n_ = value;
}

// optional string file = 10;
inline bool Request::has_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& Request::file() const {
  return *file_;
}
inline void Request::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void Request::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void Request::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* Request::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 value = 11;
inline bool Request::has_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Request::value() const {
  return value_;
}
inline void Request::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// repeated uint32 values = 12;
inline int Request::values_size() const {
  return values_.size();
}
inline void Request::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 Request::values(int index) const {
  return values_.Get(index);
}
inline void Request::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
}
inline void Request::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Request::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Request::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// Reply_RegisterInfoType

// required string name = 1;
inline bool Reply_RegisterInfoType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply_RegisterInfoType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply_RegisterInfoType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply_RegisterInfoType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Reply_RegisterInfoType::name() const {
  return *name_;
}
inline void Reply_RegisterInfoType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Reply_RegisterInfoType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Reply_RegisterInfoType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply_RegisterInfoType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Reply_RegisterInfoType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply_RegisterInfoType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Reply.RegisterType type = 2;
inline bool Reply_RegisterInfoType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply_RegisterInfoType::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply_RegisterInfoType::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply_RegisterInfoType::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Reply_RegisterType Reply_RegisterInfoType::type() const {
  return static_cast< ::Reply_RegisterType >(type_);
}
inline void Reply_RegisterInfoType::set_type(::Reply_RegisterType value) {
  assert(::Reply_RegisterType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .Reply.DeviceType device = 3;
inline bool Reply_RegisterInfoType::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply_RegisterInfoType::set_has_device() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply_RegisterInfoType::clear_has_device() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply_RegisterInfoType::clear_device() {
  device_ = 1;
  clear_has_device();
}
inline ::Reply_DeviceType Reply_RegisterInfoType::device() const {
  return static_cast< ::Reply_DeviceType >(device_);
}
inline void Reply_RegisterInfoType::set_device(::Reply_DeviceType value) {
  assert(::Reply_DeviceType_IsValid(value));
  set_has_device();
  device_ = value;
}

// required .Reply.PermissionType permission = 4;
inline bool Reply_RegisterInfoType::has_permission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply_RegisterInfoType::set_has_permission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply_RegisterInfoType::clear_has_permission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply_RegisterInfoType::clear_permission() {
  permission_ = 1;
  clear_has_permission();
}
inline ::Reply_PermissionType Reply_RegisterInfoType::permission() const {
  return static_cast< ::Reply_PermissionType >(permission_);
}
inline void Reply_RegisterInfoType::set_permission(::Reply_PermissionType value) {
  assert(::Reply_PermissionType_IsValid(value));
  set_has_permission();
  permission_ = value;
}

// required uint32 size = 5;
inline bool Reply_RegisterInfoType::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reply_RegisterInfoType::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reply_RegisterInfoType::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reply_RegisterInfoType::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 Reply_RegisterInfoType::size() const {
  return size_;
}
inline void Reply_RegisterInfoType::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// required string description = 6;
inline bool Reply_RegisterInfoType::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reply_RegisterInfoType::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reply_RegisterInfoType::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reply_RegisterInfoType::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Reply_RegisterInfoType::description() const {
  return *description_;
}
inline void Reply_RegisterInfoType::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Reply_RegisterInfoType::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Reply_RegisterInfoType::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply_RegisterInfoType::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Reply_RegisterInfoType::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply_RegisterInfoType::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Reply

// required .Reply.ResultType result = 1;
inline bool Reply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reply::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::Reply_ResultType Reply::result() const {
  return static_cast< ::Reply_ResultType >(result_);
}
inline void Reply::set_result(::Reply_ResultType value) {
  assert(::Reply_ResultType_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .Reply.PermissionType permission = 2;
inline bool Reply::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reply::set_has_permission() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reply::clear_has_permission() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reply::clear_permission() {
  permission_ = 1;
  clear_has_permission();
}
inline ::Reply_PermissionType Reply::permission() const {
  return static_cast< ::Reply_PermissionType >(permission_);
}
inline void Reply::set_permission(::Reply_PermissionType value) {
  assert(::Reply_PermissionType_IsValid(value));
  set_has_permission();
  permission_ = value;
}

// optional .Reply.TpmStatus status = 3;
inline bool Reply::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reply::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reply::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::Reply_TpmStatus Reply::status() const {
  return static_cast< ::Reply_TpmStatus >(status_);
}
inline void Reply::set_status(::Reply_TpmStatus value) {
  assert(::Reply_TpmStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional uint32 value = 4;
inline bool Reply::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reply::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reply::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reply::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Reply::value() const {
  return value_;
}
inline void Reply::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// repeated uint32 values = 5;
inline int Reply::values_size() const {
  return values_.size();
}
inline void Reply::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 Reply::values(int index) const {
  return values_.Get(index);
}
inline void Reply::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
}
inline void Reply::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Reply::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Reply::mutable_values() {
  return &values_;
}

// repeated .Reply.RegisterInfoType registerList = 6;
inline int Reply::registerlist_size() const {
  return registerlist_.size();
}
inline void Reply::clear_registerlist() {
  registerlist_.Clear();
}
inline const ::Reply_RegisterInfoType& Reply::registerlist(int index) const {
  return registerlist_.Get(index);
}
inline ::Reply_RegisterInfoType* Reply::mutable_registerlist(int index) {
  return registerlist_.Mutable(index);
}
inline ::Reply_RegisterInfoType* Reply::add_registerlist() {
  return registerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Reply_RegisterInfoType >&
Reply::registerlist() const {
  return registerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Reply_RegisterInfoType >*
Reply::mutable_registerlist() {
  return &registerlist_;
}

// optional string message = 7;
inline bool Reply::has_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Reply::set_has_message() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Reply::clear_has_message() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Reply::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Reply::message() const {
  return *message_;
}
inline void Reply::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Reply::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Reply::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reply::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Reply::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Reply::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 id = 8;
inline bool Reply::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Reply::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Reply::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Reply::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Reply::id() const {
  return id_;
}
inline void Reply::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Request_CommandType>() {
  return ::Request_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Request_DeviceType>() {
  return ::Request_DeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Request_RegisterType>() {
  return ::Request_RegisterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_ResultType>() {
  return ::Reply_ResultType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_TpmStatus>() {
  return ::Reply_TpmStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_PermissionType>() {
  return ::Reply_PermissionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_DeviceType>() {
  return ::Reply_DeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Reply_RegisterType>() {
  return ::Reply_RegisterType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
